用列表推到取代map和filter

python提供了一种精炼的写法，可以根据一份列表来复制另外一份，这种表达式称为list comprehension

字典与集合，也有和列表类似的推到机制

列表推导要比内置的map和filter函数清晰，因为它无需要额外的编写lambda表达式

列表推导可以跳过输入列表中的某些原素，如果改用map来做，那就必须辅以filter方能实现

字典与集合也支持推导表达式

不要使用含有两个以上表达式的列表推导

除了基本的用法之外，列表推导也支持多重循环

例如，要把矩阵简化成一维，是原来的每个单元格都成为列表中的普通元素
这个功能采用包含两个for表达式的列表推导即可实现

列表推导的缺点是：再推导过程中，对于输入序列中的每个值来说，
可能都要创建仅含一项的全新的列表，当输入的数据比较少时，不会出现问题
但是如如果输入的数据非常多，那么可能会消耗大量的内存，并导致程序奔溃

例如，要读取一份文件并返回每行的字符数，若采用列表推导来做，则需要把文件每一行的长度
都保存在内存中。
如果文件特别大，或是通过无休无止的network socket来读取，那么这种列表推导就会出现问题

为了解决此问题，python提供了生成器表达式(generator expression)，它对列表推导和生成器的一种番化
生成器表达式在运行的时候，并不会把整个数据序列呈现出来，而是会估值为迭代器
这个迭代器每次可以根据生成器表达式产生一项数据

把实现列表推导所用的那种写法放在一对圆括号中，就构成了生成器表达式

列表推导和生成器二者的区别在于，对于生成器表达式求值的时候，他会
立刻返回一个迭代器，而不会深入处理文件中的内容

以返回的那个迭代器为参数，逐次调用内置的next函数，即可使其按照生成器表达式来输出下一个值
可以根据自己的需要，多次命令迭代器根据生成器表达式来生成新的值，而不用担心内存用量激增

