#### 进程和线程

>>>
   
   进程是应用程序的一个执行实例

   线程是一个控制流程，可以在进程内共享其它活跃的线程同时执行

   控制流是指顺序执行一些机器指令


#### 创建线程

>>>

    threading库可以在单独的线程中执行任何的在Python中可以调用的对象
    已创建一个Thread对象并将要执行的对象以target参数的形式提供给该对象

    当创建好一个线程对象后，该对象并不会立即执行，除非调用它的start方法

    Python中的线程会在一个单独的系统级线程中执行，这些线程将由操作系统全权管理

    线程一旦启动，将独立执行直到目标函数返回

    设置daemon=True可以把线程放到后台执行

    后台线程无法等待，不过这些线程会在主线程终止时自动销毁

    如果线程执行一些像I/O这样的阻塞操作，那么通过轮询来终止线程将使得线程永远无法返回，也就无法检查自己是否以及被结束了

    由于全局解释锁的原因，python的线程被限制到同一时刻只允许一个线程执行这样一个执行模型
    所以python的线程更适用于处理I/O和其他需要并发执行的阻塞操作(例如等待I/O，等待从数据库获取数据等等)
    而不是需要多处理器并行的计算密集型任务


#### 判断一个线程是否启动

>>>
   
   threading库中的Event对象包含一个可由线程设置的信号标志，它允许线程等待某些事件的发生

   在初始情况下，event对象中的信号标志被设置为假

   如果有线程等待一个event对象，而这个event对象的标志为假，那么这个线程将会被一直阻塞直到该标志为真

   如果将一个event对象的信号标志设置为真，他将唤醒所有等待这个Event对象的线程

   如果一个线程等待一个已经被设置为真的event对象，那么他将忽略这个事件，继续执行


#### 并行计算机的内存架构

>>>
    
    - 单核处理器  单数据 sisd

    - 单核处理器  多数据 simd

    - 多核处理器  单数据 misd

    - 多核处理器  多数据 mimd

    SISD => 单核单数据，在单一的数据流上执行指令

    在SISD中指令是被顺序执行

        对于每一个CPU时钟，cpu按照下面顺序执行

        1. Fetch ： cpu从一片内存区域中(寄存器中)获取数据指令

        2. Decode： cpu对指令进行编码

        3. Excute： 该执行在数据上执行，将结果保存再另外一个寄存器上
                    excute阶段完成后，cpu回到步骤1准备执行下一个时钟循环

        -----------      instruction    -----------          -----------
        |  control  |    ===>           | processor| <===    | memory   |
        ------------                     -----------          -----------

        note: 单核的算法是顺序执行的(连续的)不存在任何并行

        这种架构的主要元素有一下：
            1. 中心内存单元：存储指令和数据
            2. cpu：用于从内存获取指令/数据，对指令的解码并顺序执行他们
            3. I/O系统：程序的输入输出流

